//**************************************************************************************
// Copyright 2008 Micron Technology, Inc. All rights reserved.
//
//
// No permission to use, copy, modify, or distribute this software and/or
// its documentation for any purpose has been granted by Micron Technology, Inc.
// If any such permission has been granted ( by separate agreement ), it
// is required that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear in
// supporting documentation, and that the name of Micron Technology, Inc. or any
// of its trademarks may not be used in advertising or publicity pertaining
// to distribution of the software without specific, written prior permission.
//
//
//	This software and any associated documentation are provided “AS IS” and 
//	without warranty of any kind.   MICRON TECHNOLOGY, INC. EXPRESSLY DISCLAIMS 
//	ALL WARRANTIES EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, NONINFRINGEMENT 
//	OF THIRD PARTY RIGHTS, AND ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS 
//	FOR A PARTICULAR PURPOSE.  MICRON DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED 
//	IN THIS SOFTWARE WILL MEET YOUR REQUIREMENTS, OR THAT THE OPERATION OF THIS SOFTWARE 
//	WILL BE UNINTERRUPTED OR ERROR-FREE.  FURTHERMORE, MICRON DOES NOT WARRANT OR 
//	MAKE ANY REPRESENTATIONS REGARDING THE USE OR THE RESULTS OF THE USE OF ANY 
//	ACCOMPANYING DOCUMENTATION IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY, 
//	OR OTHERWISE.  
//*************************************************************************************/
//
// $Revision: 16633 $
// $Date: 2007-11-01 10:46:59 -0800 (Thu, 01 Nov 2007) $ 
//
// [CHIP_DESCRIPTOR]
//    CHIPNAME = "string"
//    SERIAL_BASE_ADDRESS = hex
//    SERIAL_ADDR_SIZE = 8/16 (default 8)
//    SERIAL_DATA_SIZE = 8/16 (default 16)
// [END]
//
// [REGISTERS]
//    REGDEF = {hex, CORE/IP, hex, RW/RO, hex, "string", "string", "string"}
//      {BITDEF, hex, RW/RO, "string", "string"}
//      {BITDEF, hex, RW/RO, "string", "string"}
//      ...
//      {BITDEF, hex, RW/RO, "string", "string"}
// [END]
//
// Auto Generated by RegisterDefinitions.pl script.
// REGDEF =                     {ADDR,  TYPE,   MASK,   RW, DEFAULT, DESC, DETAIL}
//  {BITDEF,                                   MASK,   RW,          DESC, DETAIL}
//  {BITDEF,                                   MASK,   RW,          DESC, DETAIL}
//  ...
//  {BITDEF,                                   MASK,   RW,          DESC, DETAIL}

[CHIP_DESCRIPTOR]
CHIPNAME = "High Speed Serial Adapter"
SERIAL_BASE_ADDRESS = 0xCC
SERIAL_DATA_SIZE = 16
[END]

[Registers]
DESER_ROWS_UPPER       =   {0x00,     FPGA,  0xFFFF, RW, 0x0000, "Upper Word of Row", ""}
DESER_ROWS_LOWER       =   {0x01,     FPGA,  0xFFFF, RW, 0x0000, "Lower Word of Row", ""}
DESER_COLUMNS_UPPER    =   {0x02,     FPGA,  0xFFFF, RW, 0x0000, "Upper Word of Column", ""}
DESER_COLUMNS_LOWER    =   {0x03,     FPGA,  0xFFFF, RW, 0x0000, "Lower Word of Column", ""}
DESER_SHUTTER_DELAY    =   {0x04,     FPGA,  0xFFFF, RW, 0x0000, "Shutter Delay", ""}
DESER_CONTROL1         =   {0x05,     FPGA,  0x0FFF, RW, 0x0000, "Misc Control Signals", ""}
   {SLAVEMODEENABLE,                         0x0001, RW,         "Slave Mode Enable", "1 = SlaveMode;  0 = MasterMode"}
   {FORCESTART,                              0x0002, RW,         "Force Start", "1= Start capture; 0 = Stop capture"}
   {CONTRESTART,                             0x0004, RW,         "Continuous Restart", "1 = video mode ; 0= single frame"}
   {TWELVEBITDATA,                           0x0008, RW,         "Twelve Bit Data", "1 =12 bits per pixel; 0 = 14 bits per"}
   {SYNC_MSB,                                0x0010, RW,         "Sync MSB", "Sync Code: 1= MSB First; 0 = MSB last"}
   {MSBFIRST,                                0x0020, RW,         "MSB First", "This bit should match the associated MSB First bit in the device registers"}
   {RESETFIFOS,                              0x0040, RW,         "Reset Fifos", "Reset fifos. This bit actually works for all fifos in the RTL."}
   {FORCEFIFOREAD,                           0x0080, RW,         "Force Fifo ReadEN", "Force the Fifo Read Enable to 1"}
   {DUTCLKPLLSRC,                            0x0100, RW,         "Dut Clk PLL Source", "0: DutClk from Personality card, 1: Fixed 50Mhz Clk"}
   {DUTCLKPLLLOCKED,                         0x0200, RO,         "Dut Clk PLL Locked", "1 indicates that the PLL is locked"}
   {SERQUADSELECT,                           0x0C00, RW,         "Serial Quad Select", "Select one of the 4 Quads of serial data."}
DESER_CONTROL2         =   {0x06,     FPGA,  0x007F, RW, 0x0000, "Misc Control Signals", ""}
   {PLLCLKINPUTREG,                          0x0001, RW,         "PLL Clk Input Src", "0 = LvdsClk[0], 1 = 50Mhz Clk"}
   {RECONFIGSTARTREG,                        0x0002, WO,         "Reconfig Start", "1 = pll reconfig; 0 = no reconfig pll"}
   {RECONFIGARESETEN,                        0x0004, RW,         "Reconfig Async Reset", "pll fsm: 1 =goto reset state; 0= run "}
   {RECONFIGREGEN,                           0x0008, RW,         "Reconfig Enable", "1 = goto enable state of pll recofig fsm;"}
   {RECONFIGLOGICDATASEl,                    0x0010, RW,         "Reconfig Logic Select", "select logic analysis bus"}
   {RECONFIGREADNWRITE,                      0x0040, RW,         "Reconfig Read nWrite", "1 = readout data; 0= write data in"}
   {PLLLOCKED,                               0x0080, RO,         "PLL Locked", "Indicates if the PLL Is locked or not"}
DESER_CONTROL3         =   {0x07,     FPGA,  0xFFFF, RW, 0x0000, "Misc Control Signals", ""}
   {TYPE,                                    0x000F, RW,         "Type", "select counter type to update"}
   {PARAM,                                   0x0070, RW,         "Param", "select parameter of counter to update"}
   {DATAIN,                                  0xFF80, RW,         "Datain", "parameter data to write"}
DESER_HSYNC_CODE       =   {0x08,     FPGA,  0x00FF, RW, 0x0000, "Horizontal Sync Code", "8 bit value that is used to generate the 12 or 14 bit extended sync code for Horizontal Sync"}
DESER_VSYNC_CODE       =   {0x09,     FPGA,  0x00FF, RW, 0x0000, "Vertical Sync Code", "8 bit value that is used to generate the 12 or 14 bit extended sync code for Vertical Sync"}
DESER_QUOTIENT         =   {0x0A,     FPGA,  0xFFFF, RW, 0x0000, "Quotient", "Set this value to Int(Sutter/Rows)"}
DESER_REMAINDER        =   {0x0B,     FPGA,  0xFFFF, RW, 0x0000, "Remainder", "Set this to the remainder of (Shutter/Rows)"}
DESER_SKIPROWS         =   {0x0C,     FPGA,  0xFFFF, RW, 0x0000, "Skip Rows", "Number of rows to skip after Vsync. Use to skip the non visible rows."}
DESER_SKIPCOLS         =   {0x0D,     FPGA,  0xFFFF, RW, 0x0000, "Skip Columns", "Skip the specified number of columns after Hsync. In terms of pixels, this value is in multiples of 16."}
DESER_FRAMEDELAY       =   {0x0E,     FPGA,  0xFFFF, RW, 0x0000, "Frame Delay", "Delay from receipt of Vsync to start of Frame Valid"}
DESER_SYNCLOC          =   {0x0F,     FPGA,  0xFFFF, RW, 0x0000, "SyncLocation", "Controls position of serial data sync latches."}
   {DATALATCHLOC,                            0x0007, RW,         "Data Latch Location", ""}
   {DATAONESHIFT,                            0x0008, RW,         "Data One Shift", ""}
   {COUNT6LOC,                               0x0070, RW,         "Count 6 Location", ""}
   {COUNT7LOC,                               0x0700, RW,         "Count 7 Location", ""}
   {USEREFORDDR,                             0xF000, RW,         "Use RE for DDR", "If set high, use the Rising Edge of DDR clock as the first bit of each sequence"}
MODECONTROL            =   {0x10,     FPGA,  0xFFFF, RW, 0x0000, "ModeControl", ""}
   {SELECTWIDE,                              0x0001, RW,         "Cameralink Wide Select", "0 = Parallel Out; 1 = Wide Camera Link Selects narrow Camera Link channel or parallel test channel"}
   {SELECTNARROW,                            0x0002, RW,         "Cameralink Narrow Select", "0 = Parallel Out; 1 = Wide Camera Link Selects wide Camera Link channel or parallel test channel"}
   {TEST,                                    0x0004, RW,         "Test Pin Control", "Fabrication Test Pin"}
   {SKIPMULTIPLERESET,                       0x0008, RW,         "Skip Multiple Resets Select", "0=Disabled, 1=Enabled"}
   {TRIGGERSTART,                            0x0010, WO,         "Trigger Start Control", "1=Trigger Start"}
   {TRIGGERMODE,                             0x0020, RW,         "Trigger Mode Select", "0=Single Pulse, 1=Repetitive"}
   {I2CTRIGGER,                              0x0040, RW,         "I2C control trigger", "I2C control trigger"}
   {FRAME_TRIG_SEL,                          0x1000, RW,         "Frame Trigger Select", "0=Scan Chain, 1=Slave Mode Controller"}
   {MASTER_SEL,                              0x2000, RW,         "Master Select", "0=Scan Chain, 1=Local Control"}
   {PRESCALERSEL0,                           0x4000, RW,         "Low bit of Prescaler select", "0=divide-by-1, 1=divide-by-16, 2=divide-by-256, 3=divide-by-65536"}
   {PRESCALERSEL1,                           0x8000, RW,         "high bit of Prescaler select", "0=divide-by-1, 1=divide-by-16, 2=divide-by-256, 3=divide-by-65536"}
MODECONTROL2           =   {0x11,     FPGA,  0xFFFF, RW, 0x0000, "ModeControl2", ""}
   {INVERTPIXCLK,                            0x0001, RW,         "Invert Par Pixel Clk", "0 selects the rising edge of PixClk to latch parallel data. 1 Selects the falling edge"}
   {SERIALDEPTH,                             0x0002, RW,         "Serial Depth", "0: 12-bit, 1: 14-bit"}
   {PIXSOURCE,                               0x0030, RW,         "Pixel Source", "0: Decimated Serial, , 1: Bypass Serial, 2: Test Pattern, 3: FrameBuf Serial"}
   {PARALLELENABLE,                          0x0040, RW,         "Parallel Enable", "0: Use PixSource, 1: Enable Parallel Mode"}
   {MASTER_CONTROL,                          0x0080, RW,         "Master Control", "0: Enable, 1: Disable"}
   {TAPCOUNT,                                0x0300, RW,         "Cameralink Tap Count", "0: 1 Tap, 1: Dual Tap, 2: Undefined, 3: Quad Tap"}
   {TWOCHANNEL,                              0x0400, RW,         "Two Channels Only", "1: 2 channels only"}
   {HISPIMODE_SEL,                           0x3000, RW,         "Hispi Mode Select", "0: HispiS, 1:HispiSP, 2: HispiDSLR, 3: invalid"}
   {STREAMMODE,                              0x4000, RW,         "HispiSP stream Mode", "0: Stream, 1: Packet"}
DESERIALIZER_VERSION   =   {0x12,     FPGA,  0xFFFF, RO, 0x0015, "FPGA Version", "FPGA Version "}
   {VER_MINOR,                               0x000F, RO,         "Minor Version", "3-0: Firmware Minor Version #"}
   {VER_MAJOR,                               0x00F0, RO,         "Major Version", "7-4: Firmware Major Version #"}
   {SUPER_MAJOR,                             0xFF00, RO,         "Upper Version bits", "15-8: Firmware Super Major Version "}
CHIP_VERSION_REG       =   {0x13,     FPGA,  0xFFFF, RO, 0x00CC, "Chip ID", ""}
DESERIALIZER_DATESTAMPREG =   {0x14,     FPGA,  0xFFFF, RO, 0x7288, "Firmware Build DateStamp", "m/d/y"}
DESERIALIZER_TIMESTAMPREG =   {0x15,     FPGA,  0xFFFF, RO, 0x1626, "Firmware Build TimeStamp", "h/m/s"}
DES_TESTPATCTRL        =   {0x16,     FPGA,  0xFFFF, RW, 0x0000, "Test Pattern Control Reg", ""}
   {TESTPATTERNMODE,                         0x000F, RW,         "TestPatMode", "Set the test pattern mode. 0: RowCounter, 1: Row/Col Counter 2: Column Counter 3: ColCOunter 2 4: Fixed"}
   {TPFIXEDVALUE,                            0xFFF0, RW,         "TestPatFixedValue", "Fixed Value for the test pattern in fixed mode."}
DESER_SYNCLOC2         =   {0x17,     FPGA,  0xFFFF, RW, 0x0000, "SyncLocation 2", "Controls position of serial data sync latches."}
   {DATALATCHLOC0,                           0x0007, RW,         "Data Latch Location 0", "Shift the Serial->Parallel point in steps of 2 bits."}
   {DATAONESHIFT0,                           0x0008, RW,         "Data Shift by One 0", "Shift Data one bit."}
   {DATALATCHLOC1,                           0x0070, RW,         "Data Latch Location 1", "Shift the Serial->Parallel point in steps of 2 bits."}
   {DATAONESHIFT1,                           0x0080, RW,         "Data Shift by One 1", "Shift Data one bit."}
   {DATALATCHLOC2,                           0x0700, RW,         "Data Latch Location 2", "Shift the Serial->Parallel point in steps of 2 bits."}
   {DATAONESHIFT2,                           0x0800, RW,         "Data Shift by One 2", "Shift Data one bit."}
   {DATALATCHLOC3,                           0x7000, RW,         "Data Latch Location 3", "Shift the Serial->Parallel point in steps of 2 bits."}
   {DATAONESHIFT3,                           0x8000, RW,         "Data Shift by One 3", "Shift Data one bit."}
DESER_COUNT6LOC        =   {0x18,     FPGA,  0x7777, RW, 0x0000, "Count6Location", "Controls position of serial data sync latches."}
   {COUNT6LOC0,                              0x0007, RW,         "Count 6 Location 0", "Location of bit in Count6 shift register."}
   {COUNT6LOC1,                              0x0070, RW,         "Count 6 Location 1", "Location of bit in Count6 shift register."}
   {COUNT6LOC2,                              0x0700, RW,         "Count 6 Location 2", "Location of bit in Count6 shift register."}
   {COUNT6LOC3,                              0x7000, RW,         "Count 6 Location 3", "Location of bit in Count6 shift register."}
DESER_COUNT7LOC        =   {0x19,     FPGA,  0x7777, RW, 0x0000, "Count7Location", "Controls position of serial data sync latches."}
   {COUNT7LOC0,                              0x0007, RW,         "Count 7 Location 0", "Location of bit in Count6 shift register."}
   {COUNT7LOC1,                              0x0070, RW,         "Count 7 Location 1", "Location of bit in Count6 shift register."}
   {COUNT7LOC2,                              0x0700, RW,         "Count 7 Location 2", "Location of bit in Count6 shift register."}
   {COUNT7LOC3,                              0x7000, RW,         "Count 7 Location 3", "Location of bit in Count6 shift register."}
DESER_VSYNCMON         =   {0x1A,     FPGA,  0xFFFF, RO, 0x0000, "VSyncMon", "Vertical Sync Monitor. A 1 in any bit location indicates that a sync was detected during the last time slice. Time slices are about 333ms, depending on the actual frequency of the Serial data."}
DESER_HSYNCMON         =   {0x1B,     FPGA,  0xFFFF, RO, 0x0000, "HSyncMon", "Horizontal Sync Monitor. A 1 in any bit location indicates that a sync was detected during the last time slice. Time slices are about 333ms, depending on the actual frequency of the Serial data."}
TRIGGER_WIDTH          =   {0x1C,     FPGA,  0xFFFF, RW, 0x0000, "TriggerWidth", "Trigger pulse width count"}
LOW_WIDTH              =   {0x1D,     FPGA,  0xFFFF, RW, 0x0000, "LowWidth", "the time between two adjacent pulses (Low width count)"}
CCPREG                 =   {0x1E,     FPGA,  0xFFFF, RW, 0x0000, "CCP Register", "CCP Control Register"}
MIPICONTROLSTATUS      =   {0x1F,     FPGA,  0xFFFF, RW, 0x0000, "MIPI Control/Status Register", ""}
   {PARMUXSEL0,                              0x0001, RW,         "Parallel Output Mux selection", "0 = MIPI,1 = TP, 2 = CCP, 3 = Parallel,4=HiSpi"}
   {PARMUXSEL1,                              0x0002, RW,         "Parallel Output Mux selection", "0 = MIPI,1 = TP, 2 = CCP, 3 = Parallel,4=HiSpi"}
   {PARMUXSEL2,                              0x0004, RW,         "Parallel Output Mux selection", "0 = MIPI,1 = TP, 2 = CCP, 3 = Parallel,4=HiSpi"}
   {TERMEN,                                  0x0040, RW,         "CCP Termination Control bit", "1=Enable Termination"}
   {MODE,                                    0x0080, RW,         "CCP and MIPI selection", "1=CCP, 0 = MIPI"}
   {LANECOUNT,                               0x0300, RW,         "MIPI Lane Count", "0=Single Lane, 1= Dual Lanes"}
   {RESETFV,                                 0x1000, RW,         "MIPI Frame Valid Reset", "1=Reset Fame Valid"}
   {RESETLV,                                 0x2000, RW,         "MIPI Line Valid Reset", "1=Reset Line Valid"}
FRAMEBUFFER            =   {0x20,     FPGA,  0xFFFF, RW, 0x0000, "Frame Buffer Reg", ""}
   {FRAMEBUFFERRESET,                        0x0001, WO, 0x0000, "Frame Buffer Reset", "0-Normal Operation; 1-Reset"}
FRAMEBUF_STATUS        =   {0x21,     FPGA,  0xFFFF, RW, 0x0000, "Misc Control Signals", ""}
   {DROPPINGFRAMES,                          0x0002, RO,         "Dropping Frames", "Signal is high if frame buffer is dropping frames."}
   {SHUTTER,                                 0x0004, RO,         "Shutter Status", "Shutter Status"}
   {GPI_B,                                   0x00F0, RO,         "GPI Status", "GPI Status"}
   {DATAPRESENT,                             0x1000, RO,         "Data Present", "1-Data is present in the Frame Buffer"}
   {FBC_STATE,                               0x6000, RO,         "FBC State", "State of the FBC 0-idle;1-Armed; 2-Capture; 3-Read"}
FRAMEBUF_CONTROL       =   {0x22,     FPGA,  0xFFFF, RW, 0x0000, "Frame Buffer Control", "Misc Control Signals"}
   {ONESHOTMODE,                             0x0001, RW, 0x0000, "One Shot Mode", "0-Free Running; 1-One Shot"}
   {SW_TRIGGER,                              0x0002, WO, 0x0000, "SW Trigger", "0-1 Causes a trigger event in one shot mode"}
   {FG_ENABLE,                               0x0004, RW, 0x0000, "FG Enable", "0-Disable Frame Generator; 1-Enable Frame Generator"}
   {FB_RESET,                                0x0008, RW, 0x0000, "Frame Buffer Reset", "0-Normal Operation; 1-Reset FB/FC/FG"}
FBC_TARGETFRAMECOUNT   =   {0x23,     FPGA,  0xFFFF, RW, 0x0002, "Target Frame Count", "How Many Frames should the Controller Capture"}
FB_FRAMECOUNT          =   {0x24,     FPGA,  0xFFFF, RO, 0x0000, "Captured Frames Low", "Low 16 bits of Captured frame count"}
FB_DROPPEDFRAMES       =   {0x25,     FPGA,  0xFFFF, RO, 0x0000, "Dropped Frames Low", "Low 16 bits of Dropped frame count"}
FB_COUNTS              =   {0x26,     FPGA,  0xFFFF, RO, 0x0000, "Frame Buffer Counts", ""}
   {CAPTUREDFRAMECOUNT,                      0x00FF, RO,         "CapturedFrames High", "High 8 bits of Captured frame count"}
   {DROPPEDFRAMECOUNT,                       0xFF00, RO,         "Dropped Frames High", "High 8 bits of Dropped frame count"}
LOGICSELECT            =   {0x30,     FPGA,  0x0FFF, RW, 0x0000, "Logic Select", "Logic Analyzer Select"}
   {LASELPORTA,                              0x000f, RW,         "Logic Port Select", "Logic analyzer A source data mux control"}
   {LASELSER,                                0x0070, RW,         "IntSerial Port Select", "Internal Select for Serial conroller serial bits"}
   {LAPIXSEL,                                0x0f00, RW,         "Serial Pixel 1 of 16 select", "Select one of the 16 bit Pixel lanes from the ouput of the Seral Sync blocks"}
   {LAAUXSEL,                                0xf000, RW,         "Aux Selector", "Allow for selecting aux its in the pixel."}
ADCSWEEPCONTROL        =   {0x40,     FPGA,  0x000F, RW, 0x0000, "ADCSweepControl", "Provide support for ADC sweep"}
   {RUN,                                     0x0001, RW,         "Run Enable", "Continuous GatedFrameValid"}
   {ONEFRAMEENABLE,                          0x0002, WO,         "One Frame Enable", "Single GatedFrameValid"}
   {LAGENABLE,                               0x0004, RW,         "Lag Enable", "LagEnable bit"}
DES_SIGNAL_MON_G0      =   {0xA0,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
DES_SIGNAL_MON_G1      =   {0xA1,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
DES_SIGNAL_MON_G2      =   {0xA2,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
DES_SIGNAL_MON_G3      =   {0xA3,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
DES_SIGNAL_MON_G4      =   {0xA4,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
DES_SIGNAL_MON_G5      =   {0xA5,     FPGA,  0xFFFF, RO, 0x0000, "Signal Monitor Group1", "Toggle State"}
[END]
