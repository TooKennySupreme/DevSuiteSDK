; WIP Last Changed Rev: 2336
;**************************************************************************************
; Copyright 2010 Aptina Imaging Corporation. All rights reserved.
;
;
; No permission to use, copy, modify, or distribute this software and/or
; its documentation for any purpose has been granted by Aptina Imaging Corporation.
; If any such permission has been granted ( by separate agreement ), it
; is required that the above copyright notice appear in all copies and
; that both that copyright notice and this permission notice appear in
; supporting documentation, and that the name of Aptina Imaging Corporation or any
; of its trademarks may not be used in advertising or publicity pertaining
; to distribution of the software without specific, written prior permission.
;
;
;      This software and any associated documentation are provided "AS IS" and
;      without warranty of any kind.   APTINA IMAGING CORPORATION EXPRESSLY DISCLAIMS
;      ALL WARRANTIES EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, NONINFRINGEMENT
;      OF THIRD PARTY RIGHTS, AND ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
;      FOR A PARTICULAR PURPOSE.  APTINA DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED
;      IN THIS SOFTWARE WILL MEET YOUR REQUIREMENTS, OR THAT THE OPERATION OF THIS SOFTWARE
;      WILL BE UNINTERRUPTED OR ERROR-FREE.  FURTHERMORE, APTINA DOES NOT WARRANT OR
;      MAKE ANY REPRESENTATIONS REGARDING THE USE OR THE RESULTS OF THE USE OF ANY
;      ACCOMPANYING DOCUMENTATION IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY,
;      OR OTHERWISE.
;*************************************************************************************/
; Default INI file for ICP-HD REV1-67 (Chip ID 0x0EC1)
;
; $Revision: 28443 $
; $Date: 2011-06-30 09:36:34 -0700 (Thu, 30 Jun 2011) $
;
; This file holds groups of register presets (sections) specific for this sensor. The
; presets allow you to overwrite the power-on default settings with optimized register
; settings.
; The [Demo Initialization] section contains all optimized register settings for running
; the sensor in the demo environment. Other sections include settings optimized for a
; variety of situations like: Running at different master clock speeds, running under
; different lighting situations, running with different lenses, etc.
; Most of the demonstration software (DevWare, SensorDemo, ...) make use of this file
; to load and store the user presets.
;
; Keyname description:
; REG      = assign a new register value
; BITFIELD = do a READ-MODIFY-WRITE to part of a register. The part is defined as a mask.
; FIELD_WR = Write any register, variable or bitfield, specified by its symbol name
; LOAD     = load an alternate section from this section
; STATE    = set non-register state
; DELAY    = delay a certain amount of milliseconds before continuing
; POLL_REG = Read a register a specified number of times, or until the register
;            value no longer meets a specified condition. You specify the
;            register by its address, and it only works with simple registers.
;            You also specify a delay between each iteration of the loop.
; POLL_FIELD = Like POLL_REG except you specify the register by its symbol name
;            as defined in the sensor data file. POLL_FIELD works with any kind
;            of register or variable.
;
; Keyname format:
; REG      = [<page>,] <address>, <value>             //<comment>
; BITFIELD = [<page>,] <address>, <mask>, <value>
;            Some examples:
;            BITFIELD=2, 0x05, 0x0020, 1 //for register 5 on page 2, set the 6th bit to 1
;            BITFIELD=0x06, 0x000F, 0    //for register 6, clear the first 4 bits
; FIELD_WR = <registername>, [<bitfieldname>,] <value>
; LOAD     = <section>
; STATE    = <state>, <value>
; DELAY    = <milliseconds>
; POLL_REG = [<page>,]<address>,<mask>,<condition>,DELAY=<milliseconds>,TIMEOUT=<count> //<comment>
;            Example:  Poll every 50ms, stop when value <= 8 or after 5 times (250ms).
;            POLL_REG= 2, 0x3F, 0xFFFF, >8, DELAY=50, TIMEOUT=5
; POLL_FIELD = <registername>, [<bitfieldname>,] <condition>, DELAY=<milliseconds>, TIMEOUT=<count> //<comment>
;            Example:  Poll every 10 ms, stop when the value = 0, or after 500ms.
;            POLL_FIELD= SEQ_CMD, !=0, DELAY=10, TIMEOUT=500
;
; <page>         Optional address space for this register. Some sensors (mostly SOC's)
;                have multiple register pages (see the sensor spec or developer's guide)
; <address>      the register address
; <value>        the new value to assign to the register
; <mask>         is the part of a register value that needs to be updated with a new value
; <registername> Name of a register or variable as defined the sensor data (.sdat) file
; <bitfieldname> Optional name of a bitfield
; <condition>    <  <=  ==  !=  >  or  >=  followed by a numerical value
; <count>        Number of iterations of the polling loop
; <section>      the name of another section to load
; <state>        non-register program state names [do not modify]
; <milliseconds> wait for this ammount of milliseconds before continuing
; <comment>      Some form of C-style comments are supported in this .ini file
;
;*************************************************************************************/
;
# DevWare INI file for iCp-HD XML file downloading

[Reset]
PYTHON= devware.command(devware.ID_APP_STOP)
STATE= Sensor Reset, 1
DELAY= 10
STATE= Sensor Reset, 0
DELAY= 10
STATE= Sensor Reset, 1
DELAY= 10
STATE= Sensor Reset, 0
DELAY= 10

[Demo Initialization]
STATE= Sensor Reset, 1
DELAY= 10
STATE= Sensor Reset, 0
DELAY= 10
STATE=SHiP Speed, 400
LOAD= Python:
PROMPT= "Choose which type of sensor data interface", "Parallel", LOAD=XML 8140 Parallel, "MIPI", LOAD=XML 8140 MIPI, "Custom", LOAD=XML Custom, "Browse for XML file...", LOAD=XML Browse
;LOAD= Python: load_hp_all
LOAD= WDR ON

// Recommended Settings
REG= 0x100E, 0x08  // Default Zoom step size

[XML 8140 Parallel]
LOAD = Python: xml_8140_parallel

[XML 8140 MIPI]
LOAD = Python: xml_8140_mipi

[XML TestPattern]
LOAD = Python: testPattern
REG = 0x2000, 320
REG = 0x2002, 240

[XML Custom]
LOAD = Python: custom

[XML Browse]
LOAD = Python: Browse

[Python: testPattern]
loadXML('testpattern_patch.xml')

[Python: custom]
loadXML('mt9f311-rev1-76_mt9e013_p_p_rev3.xml')

[Python: Browse]
title = 'Select ICP-HD XML File'  #  Window title bar
initialdir = os.path.dirname(__IniFileName)
def_extension = 'xml'  #  default file extension
filter = 'XML Files\0*.xml\0All Files\0*.*\0\0' # file extension filters
dropname = OpenFileDialog(title, initialdir, def_extension, filter)
if (dropname != None):
	loadXML(dropname)

[Python: xml_8140_parallel]
loadXML('mt9f311-rev1-76_mt9e013_p_p_rev3.xml')

[Python: xml_8140_mipi]
loadXML('mt9f311-rev1-76_mt9e013_m2_p_rev3.xml')

[Python: basic_init_lp_parallel]
load_basic_lp('icop_patch_rel_35_mt9e013_7017_parallel.xml')

[Python: basic_init_lp_mipi]
load_basic_lp('icop_patch_rel_35_mt9e013_7017_mipi.xml')

[Python: input_capture]
threading.Thread(target=thread_capture).start()

[Python: input_capture_full]
threading.Thread(target=thread_capture_full).start()

[Python: set_AE_ROI]
set_ae_roi()

[Python: set_AF_ROI]
set_af_roi()

[Python: AntiShake_Demo]
threading.Thread(target=antishake_demo).start()

[Python: load_hp_all]
loadXML_hp_all('rel_101026_fw71-mcnex\\fw\\mt9f311-rev1_mt9e013_m2_p_mcnex.xml')

[Python: load_lp_all]
#loadXML_lp_all('rel_101026_fw70-WIP\\fw\\mt9f311-rev1_mt9e013_m2_p_semco-ccs-24.xml')
loadXML_lp_all('rel_101026_fw71-mcnex\\fw\\mt9f311-rev1_mt9e013_m2_p_mcnex.xml')

[Python: basic_init_hp]
loadXML_basic_hp('ASIC_PATCH\\rel_100819_fw47\\fw\\mt9f311-rev1_mt9e013_m2_p_semco-ccs-24.xml')

[Python: patch_hp]
loadXML_hp('ASIC_PATCH\\rel_100819_fw47\\fw\\mt9f311-rev1_mt9e013_m2_p_semco-ccs-24.xml')

[Python: scratchpad_hp]
load_Scratchpad_hp('ASIC_PATCH\\rel_100819_fw47\\fw\\mt9f311-rev1_mt9e013_m2_p_semco-ccs-24.xml')

[Python: scratchpad_lp]
load_Scratchpad_lp('icop_patch_rel_35_mt9e013_7017_parallel')

[Python: basic_init_lp]
load_basic_init_lp('icop_patch_rel_35_mt9e013_7017_parallel')

[Python: patch_lp]
load_patch_lp('icop_patch_rel_35_mt9e013_7017_parallel')

[Python: run]
unstall_fw()

[Python: Verify Verbose]
verify_verbose()

[Viewfinder ON]
FIELD_WR= CTRL, ST, 0
FIELD_WR= CTRL, CNTX, 0

[Viewfinder OFF]
FIELD_WR= CTRL, CNTX, 1

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////Functional Demo///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////Dropdown_1////////////////////////////////////////////////////////
[Toolbar: Face Modes]
ICON= icons\face-detect-24.bmp
TOOLTIP= "Toggle the Face/Smile/Blink Detections"
MENUITEM= "Face Detection",	LOAD= Face Detection,	CHECKED=PREVIEW_CTRL:FACED==1, TOOLTIP="Enable/Disable Face Detection"
MENUITEM= "Smile Detection",	LOAD= Smile Detection,	CHECKED=PREVIEW_CTRL:SMILE==1, TOOLTIP="Enable/Disable Smile Detection"
MENUITEM= "Blink Detection",	LOAD= Blink Detection,	CHECKED=PREVIEW_CTRL:BLINK==1, TOOLTIP="Enable/Disable Blink Detection"
MENUITEM= "-"
MENUITEM= "Face/Smile/Blink Off",	LOAD= Face Smile Blink Off, TOOLTIP="Disable Face/Smile/Blink Detection"
MENUITEM= "Face/Smile/Blink On",	LOAD= Face Smile Blink On, TOOLTIP="Enable Face/Smile/Blink Detection"
MENUITEM= "Face/Smile On",		LOAD= Face Smile On, TOOLTIP="Enable Face/Smile Detection"
MENUITEM= "Face/Blink On",		LOAD= Face Blink On, TOOLTIP="Enable Face/Blink Detection"
MENUITEM= "-"
// MENUITEM= "Shutter Control",	LOAD= Shutter Control,	CHECKED= S2_CTRL:FACES==1
MENUITEM= "Face-box On/Off",	LOAD= Facebox Control,	CHECKED= PREVIEW_CTRL:FACEO==1

[Toolbar: Scene Modes]
ICON= icons\backlight-24.bmp
TOOLTIP= "Select the scene mode"
MENUITEM= "Auto",		LOAD= Auto Scene,	CHECKED= SCENE_MODE:AUTO==1
MENUITEM= "-"
MENUITEM= "Normal",		LOAD= Normal Scene,	RADIO= SCENE_MODE:MODE==0
MENUITEM= "Portrait",		LOAD= Portrait Scene,	RADIO= SCENE_MODE:MODE==1
MENUITEM= "Landscape",		LOAD= Landscape Scene,	RADIO= SCENE_MODE:MODE==2
MENUITEM= "Sport",		LOAD= Sport Scene,	RADIO= SCENE_MODE:MODE==3
MENUITEM= "Close-up",		LOAD= Close-up Scene,	RADIO= SCENE_MODE:MODE==4
MENUITEM= "Night",		LOAD= Night Scene,	RADIO= SCENE_MODE:MODE==5
MENUITEM= "Twilight",		LOAD= Twilight Scene,	RADIO= SCENE_MODE:MODE==6
MENUITEM= "Backlit",		LOAD= Backlight Scene,	RADIO= SCENE_MODE:MODE==7
MENUITEM= "High Sensitivity",	LOAD= HighSens Scene,	RADIO= SCENE_MODE:MODE==8
MENUITEM= "Night Portrait",	LOAD= Night Portrait,	RADIO= SCENE_MODE:MODE==9
MENUITEM= "Beach",		LOAD= Beach Scene,	RADIO= SCENE_MODE:MODE==10
MENUITEM= "Document",		LOAD= Document Scene,	RADIO= SCENE_MODE:MODE==11
MENUITEM= "Party",		LOAD= Party Scene,	RADIO= SCENE_MODE:MODE==12
MENUITEM= "Fireworks",		LOAD= Fireworks Scene,	RADIO= SCENE_MODE:MODE==13
MENUITEM= "Sunset",		LOAD= Sunset Scene,	RADIO= SCENE_MODE:MODE==14

[Toolbar: Bracketing]
ICON= icons\multi-still-24.bmp
TOOLTIP= "Select the bracketing options"
MENUITEM= "Off",		LOAD= Bracket Off, 	RADIO= BRAC_NUM_STEPS == 0
MENUITEM= "Brightness",		LOAD= Bracket Exposure,	RADIO= BRAC_PARAM_SEL == 0
MENUITEM= "ISO Number",		LOAD= Bracket ISO,	RADIO= BRAC_PARAM_SEL == 1
MENUITEM= "Color Temperature",	LOAD= Bracket Color,	RADIO= BRAC_PARAM_SEL == 2
MENUITEM= "Green Gain",		LOAD= Bracket Green,	RADIO= BRAC_PARAM_SEL == 3
MENUITEM= "Contrast",		LOAD= Bracket Contrast,	RADIO= BRAC_PARAM_SEL == 4
MENUITEM= "Lens Position",	LOAD= Bracket Lens,	RADIO= BRAC_PARAM_SEL == 5


[Toolbar: Metering Modes]
ICON= icons\metering-24.bmp
TOOLTIP= "Select the auto exposure mode"
MENUITEM= "Average",		LOAD= Average AE,	RADIO= AE_MET==0
MENUITEM= "Wide Center",	LOAD= Wide Center AE,	RADIO= AE_MET==1
MENUITEM= "Narrow Center",	LOAD= Narrow Center AE,	RADIO= AE_MET==2
MENUITEM= "Spot",		LOAD= Spot AE,		RADIO= AE_MET==3
MENUITEM= "Manual/Table",	LOAD= Manual AE,	RADIO= AE_MET==4

[Toolbar: Effects]
ICON= icons\magic-wand.ico
TOOLTIP= "Select the Image Special Effect"
MENUITEM= "Normal",		LOAD= Normal Mode,	RADIO= SFX_MODE:SFX==0
MENUITEM= "Alien", 		LOAD= Alien Mode,	RADIO= SFX_MODE:SFX==1
MENUITEM= "Antique",		LOAD= Antique Mode,	RADIO= SFX_MODE:SFX==2
MENUITEM= "Black/White",	LOAD= B/W Mode, 	RADIO= SFX_MODE:SFX==3
MENUITEM= "Emboss", 		LOAD= Emboss Mode,	RADIO= SFX_MODE:SFX==4
MENUITEM= "Emboss/Color",	LOAD= Emboss/Color Mode,RADIO= SFX_MODE:SFX==5
MENUITEM= "Grayscale",		LOAD= Grayscale Mode,	RADIO= SFX_MODE:SFX==6
MENUITEM= "Negative", 		LOAD= Negative Mode,	RADIO= SFX_MODE:SFX==7
MENUITEM= "Blueish",		LOAD= Blueish Mode,	RADIO= SFX_MODE:SFX==8
MENUITEM= "Greenish",		LOAD= Greenish Mode,	RADIO= SFX_MODE:SFX==9
MENUITEM= "Redish", 		LOAD= Redish Mode,	RADIO= SFX_MODE:SFX==10
MENUITEM= "Posterize 1",	LOAD= Posterize1 Mode,	RADIO= SFX_MODE:SFX==11
MENUITEM= "Posterize 2",	LOAD= Posterize2 Mode,	RADIO= SFX_MODE:SFX==12
MENUITEM= "Sepia 1", 		LOAD= Sepia1 Mode,	RADIO= SFX_MODE:SFX==13
MENUITEM= "Sepia 2",		LOAD= Sepia2 Mode,	RADIO= SFX_MODE:SFX==14
MENUITEM= "Sketch",		LOAD= Sketch Mode,	RADIO= SFX_MODE:SFX==15
MENUITEM= "Solarize", 		LOAD= Solarize Mode,	RADIO= SFX_MODE:SFX==16

[Toolbar: Color Modes]
ICON= icons\colorwheel.ico
TOOLTIP= "Select the white balance mode"
MENUITEM= "Auto Mode",		LOAD= Auto AWB,		RADIO= AWB_MODE:MODE==15
MENUITEM= "Temperature/Gain",	LOAD= Temp AWB,		RADIO= AWB_MODE:MODE==0
MENUITEM= "D75",		LOAD= D75 AWB,		RADIO= AWB_MODE:MODE==1
MENUITEM= "D65",		LOAD= D65 AWB,		RADIO= AWB_MODE:MODE==2
MENUITEM= "D50",		LOAD= D50 AWB,		RADIO= AWB_MODE:MODE==3
MENUITEM= "CWF",		LOAD= CWF AWB,		RADIO= AWB_MODE:MODE==4
MENUITEM= "A",			LOAD= A AWB,		RADIO= AWB_MODE:MODE==5
MENUITEM= "Horizon",		LOAD= Hroiz AWB,	RADIO= AWB_MODE:MODE==6
MENUITEM= "White Point",	LOAD= White AWB,	RADIO= AWB_MODE:MODE==7

[Toolbar: Auto Focus]
ICON= icons\antishake-24.bmp
TOOLTIP= "Select the auto focus mode"
MENUITEM= "Manual",		LOAD= Manual AF,	RADIO= AF_MODE:MODE==0
MENUITEM= "Single",		LOAD= Single AF,	RADIO= AF_MODE:MODE==1
MENUITEM= "Continuous",		LOAD= Continuous AF,	RADIO= AF_MODE:MODE==3
MENUITEM= "Continuous Single",	LOAD= Continuous Single AF,	RADIO= AF_MODE:MODE==4
MENUITEM= "-"
MENUITEM= "Face ROI On/Off",	LOAD= FACEROI AF,	CHECKED= AF_MODE:FACE_ROI_ENABLE==1
MENUITEM= "Center On/Off",	LOAD= CENTER AF,	CHECKED= AF_MODE:CENTER_ROI_ENABLE==1

[Toolbar: Auto Exposure]
ICON= icons\pref-color-repro-24.bmp
TOOLTIP= "Select the auto exposure mode"
MENUITEM= "On/Off",		LOAD= Auto Exposure,	CHECKED= AE_MODE:AUTO==1
MENUITEM= "-"
MENUITEM= "Face Bound",		LOAD= FACEBOUND AE,	RADIO= AE_MODE:FACE_BOUND==1

[Toolbar: ROI AE/AF]
ICON= icons\ROI-24.bmp
TOOLTIP= "Type in the Region of Interest (ROI) for Auto Exposure or Auto Focus"
MENUITEM= "Set ROI AE",		LOAD= ROI AE
MENUITEM= "Set ROI AF",		LOAD= ROI AF

//[Toolbar: Time Stamp]
//TOOLTIP= "Show or hide time stamp on full resolution image."
//MENUITEM= "Time Stamp On",		LOAD= Time Stamp On
//MENUITEM= "Time Stamp Off",		LOAD= Time Stamp Off

//[Toolbar: Context B SpeedTags]
//LOAD=Viewfinder ON
//STATE=Filter, 0
////FIELD_WR=CAM_OUTPUT_0_JPEG_CONTROL, CAM_OUTPUT_0_JPEG_MODE_INSERT_SPEEDTAGS_MARKERS, 0x0001 	// VAR= 18, 0x00B8, 0x0040, 0x0001
///FIELD_WR=CAM_OUTPUT_1_JPEG_CONTROL, CAM_OUTPUT_1_JPEG_MODE_INSERT_SPEEDTAGS_MARKERS, 0x0001 	// VAR= 18, 0x00CE, 0x0040, 0x0001
//FIELD_WR=PREVIEW_OUT_FMT, FT, 0x0008 	// BITFIELD= 0x2018, 0x00F0, 0x0008
//
//LOAD=Viewfinder OFF
//STATE=Strip SpeedTags, 0
//STATE=Filter, 1

//[Toolbar: Enable Postview Overlay]
//FIELD_WR= SNAPSHOT_OUT_FMT, PV, 0x01
//FIELD_WR= SNAPSHOT_OUT_FMT, SS, 0x01
//STATE= Thumbnail Overlay, 1

[Toolbar: More Controls]
ICON= icons\magic-wand.ico
TOOLTIP= "Show/Hide the Sensor Control dialog"
option=SensorCtrl Show, 1

////////////////////////////////Dropdown_2////////////////////////////////////////////////////////
[Toolbar2: WDR On/Off]
ICON= icons\dyn-range-opt-24.bmp, CHECKED=ENABLE:ATM==1
TOOLTIP= "Turn On/Off the adaptive/local Tone Mapping"
IF_FIELD=ENABLE,ATM,==1,LOAD=WDR OFF,ELSELOAD=WDR ON

[Toolbar2: PCR On/Off]
ICON= icons\saturation-onoff-24.bmp, CHECKED=ENABLE:CMAP==1
TOOLTIP= "Turn On/Off the prefered color Map"
IF_FIELD=ENABLE,CMAP,==1,LOAD=Color Map OFF,ELSELOAD=Color Map ON

[Toolbar2: BPC On/Off]
ICON= icons\eraser.ico, CHECKED=ENABLE:BPC==1
TOOLTIP= "Turn On/Off defect correction"
IF_FIELD=ENABLE,BPC,==1,LOAD=Defect Correction OFF,ELSELOAD=Defect Correction ON

[Toolbar2: DeNoise On/Off]
ICON= icons\blue-qvga-24.bmp, CHECKED=ENABLE:DEN==1
TOOLTIP= "Turn On/Off de-noise filters"
IF_FIELD=ENABLE,DEN,==1,LOAD=Noise Filter OFF,ELSELOAD=Noise Filter ON

[Toolbar2: Antishake On/Off]
ICON= icons\hand_stop.ico, CHECKED=PREVIEW_CTRL:ASHAKE==1
TOOLTIP= "Turn On/Off the Antishake function"
IF_FIELD=PREVIEW_CTRL,ASHAKE,==1,LOAD=Antishake OFF,ELSELOAD=Antishake ON

[Toolbar2: Antishake Demo]
ICON= icons\magic-wand.ico
TOOLTIP= "Run the Antishake Demo sequence"
LOAD= Antishake Demo 

[Toolbar2: Batch Capture]
ICON= icons\multi-still-24.bmp
TOOLTIP= "Run the Batch Capture Demo sequence"
STATE= Still Mode, 1	//Full Size image

IF_FIELD=BRAC_PARAM_SEL==0, LOAD=Bracket Exposure
IF_FIELD=BRAC_PARAM_SEL==1, LOAD=Bracket ISO
IF_FIELD=BRAC_PARAM_SEL==2, LOAD=Bracket Color
IF_FIELD=BRAC_PARAM_SEL==3, LOAD=Bracket Green
IF_FIELD=BRAC_PARAM_SEL==4, LOAD=Bracket Contrast
IF_FIELD=BRAC_PARAM_SEL==5, LOAD=Bracket Lens

STATE= Capture Mode, 1	//trigger DevWare to Capture
STATE= Display Zoom Percent, 50

[Toolbar2: Smile Shutter OFF]
ICON= brown circle
TOOLTIP= "Restore manual shutter release mode."
LOAD= Auto Shutter Release OFF

[Toolbar2: Smile Shutter]
ICON= icons\Smiley24.bmp
TOOLTIP= "Set up the smile shutter release demo and activate."
LOAD= Smile Shutter Release Demo

[Toolbar2: No-Blink Shutter]
//ICON= icons\Smiley24.bmp
TOOLTIP= "Set up the No-Blink Shutter release demo and activate."
LOAD= No-Blink Shutter Release Demo

[Toolbar2: VGA]
ICON= icons\blue-vga-24.bmp
LOAD= Preview VGA

[Toolbar2: 720p for A8140]
ICON= icons\green-720-24.bmp
LOAD= Preview 720p

//[Toolbar2: 1080p]
//ICON= icons\orange-1080-24.bmp
//LOAD= Preview 1080p

[Toolbar2: QVGA with DVS]
TOOLTIP= "Video Stabilization fully done by iCP-HD"
FIELD_WR= PREVIEW_CTRL, DVS, 0
FIELD_WR= PREVIEW_WIDTH, 320
FIELD_WR= PREVIEW_HEIGHT, 240
FIELD_WR= PREVIEW_DVS_SR, 32 // search range
FIELD_WR= PREVIEW_CTRL, DVS, 2

[Toolbar2: 720p+DVS-assist]
TOOLTIP= "Video Stabilization assist by iCP-HD, with cropping on the host"
FIELD_WR= PREVIEW_CTRL, DVS, 0
FIELD_WR= PREVIEW_WIDTH, 1472 // 1280 + 96 * 2
FIELD_WR= PREVIEW_HEIGHT, 912 // 720 + 96 * 2
FIELD_WR= PREVIEW_DVS_SR, 96 // search range
FIELD_WR= PREVIEW_CTRL, DVS, 1
[Toolbar2: DVS Split On/Off]
ICON= black square, CHECKED=STATE:DVS Split Screen==1
TOOLTIP= "Toggle between DVS split image demo and full image"
LOAD= Python: DVS Split Screen ON/OFF

[Toolbar2: Stabilization Off]
TOOLTIP= "Turn off video stabilization"
FIELD_WR= PREVIEW_CTRL, DVS, 0

[Toolbar2: Zoom to 100%]
ICON= icons\zoom_in.bmp
STATE= Display Zoom Percent, 100

[Toolbar2: Zoom to 50%]
ICON= icons\zoom_out.bmp
STATE= Display Zoom Percent, 50

[Toolbar2: Panorama Demo]
ICON= green square
TOOLTIP= "Click to demo the panoramic mode function"
LOAD= Panorama Demo

///////////////////////////////////////////////////////////////////////////////////////////////////
//Face Detection (bit 4:6)
[Face Detection]
IF_REG=0x2012,0x0010,==0,LOAD=Face Detection ON,ELSELOAD=Face Detection OFF

[Face Detection ON]
BITFIELD= 0x2012, 0x0010, 1 // PREVIEW_CTRL (Face Detection ON)
BITFIELD= 0x2012, 0x0040, 1 // PREVIEW_CTRL (Face-Box ON)

[Face Detection OFF]
BITFIELD= 0x2012, 0x0010, 0 // PREVIEW_CTRL (Face Detection OFF)
LOAD=FACE_BOX_CHECK

[Smile Detection]
IF_REG=0x2012,0x0020,==0,LOAD=Smile Detection ON,ELSELOAD=Smile Detection OFF

[Smile Detection ON]
BITFIELD= 0x2012, 0x0020, 1 // PREVIEW_CTRL (Smile Detection ON)
BITFIELD= 0x2012, 0x0040, 1 // PREVIEW_CTRL (Face-Box ON)

[Smile Detection OFF]
BITFIELD= 0x2012, 0x0020, 0 // PREVIEW_CTRL (Smile Detection OFF)
LOAD=FACE_BOX_CHECK

[Blink Detection]
IF_REG=0x2012, 0x0100,==0,LOAD=Blink Detection ON,ELSELOAD=Blink Detection OFF

[Blink Detection ON]
BITFIELD= 0x2012, 0x0100, 1 // PREVIEW_CTRL (Blink Detection ON)
BITFIELD= 0x2012, 0x0040, 1 // PREVIEW_CTRL (Face-Box ON)

[Blink Detection OFF]
BITFIELD= 0x2012, 0x0100, 0 // PREVIEW_CTRL (Blink Detection OFF)
LOAD=FACE_BOX_CHECK

[FACE_BOX_CHECK]
BITFIELD= 0x2012, 0x0040, 0                     // assume off for now, then turn on if necessary
IF_REG=0x2012,0x0010,==1,LOAD=FACE_BOX_ON       // if face detect is enabled ...
IF_REG=0x2012,0x0020,==1,LOAD=FACE_BOX_ON       // if smile detect is enabled ...
IF_REG=0x2012,0x0100,==1,LOAD=FACE_BOX_ON       // if blink detect is enabled ...

[Facebox Control]
IF_FIELD= PREVIEW_CTRL,FACEO==0, LOAD= FACE_BOX_ON, ELSELOAD= FACE_BOX_OFF

[FACE_BOX_ON]
BITFIELD= 0x2012, 0x0040, 1 // PREVIEW_CTRL (Face-Box ON)

[FACE_BOX_OFF]
BITFIELD= 0x2012, 0x0040, 0 // PREVIEW_CTRL (Face-Box OFF)

[Face Smile Blink Off]
LOAD= Face Detection OFF
LOAD= Smile Detection OFF
LOAD= Blink Detection OFF

[Face Smile Blink On]
LOAD= Face Detection ON
LOAD= Smile Detection ON
LOAD= Blink Detection ON

[Face Smile On]
LOAD= Face Detection ON
LOAD= Smile Detection ON

[Face Blink On]
LOAD= Face Detection ON
LOAD= Blink Detection ON

[Shutter Control]
IF_FIELD= PREVIEW_CTRL,FACED==0, LOAD= Face_Shutter OFF, ELSELOAD= Face_Shutter ON
IF_FIELD= PREVIEW_CTRL,SMILE==0, LOAD= Smile_Shutter OFF, ELSELOAD= Smile_Shutter ON
IF_FIELD= PREVIEW_CTRL,BLINK==0, LOAD= Blink_Shutter OFF, ELSELOAD= Blink_Shutter ON

[Face_Shutter OFF]
BITFIELD= 0x1004, 0x0001, 0 // S2_CTRL (Face_Shutter OFF)
[Smile_Shutter OFF]
BITFIELD= 0x1004, 0x0002, 0 // S2_CTRL (Smile_Shutter OFF)
[Blink_Shutter OFF]
BITFIELD= 0x1004, 0x0004, 0 // S2_CTRL (Blink_Shutter OFF)

[Face_Shutter ON]
BITFIELD= 0x1004, 0x0001, 1 // S2_CTRL (Face_Shutter ON)
[Smile_Shutter ON]
BITFIELD= 0x1004, 0x0002, 1 // S2_CTRL (Smile_Shutter ON)
[Blink_Shutter ON]
BITFIELD= 0x1004, 0x0004, 1 // S2_CTRL (Blink_Shutter ON)

//Scene Modes (Bit 0:7)
[Auto Scene]
IF_FIELD= SCENE_MODE,AUTO,==1, LOAD= Auto Scene OFF, ELSELOAD= Auto Scene ON
[Auto Scene OFF]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Auto)
[Auto Scene ON]
BITFIELD= 0x4002, 0x8000, 1 // SCENE_MODE (Auto)

[Normal Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x00FF, 0 // SCENE_MODE (Normal)

[Portrait Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x00FF, 1 // SCENE_MODE (Portrait)

[Landscape Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 2 // SCENE_MODE (Landscape)

[Sport Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 3 // SCENE_MODE (Sport)

[Close-up Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 4 // SCENE_MODE (Close-up)

[Night Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 5 // SCENE_MODE (Night)

[Twilight Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 6 // SCENE_MODE (Twilight)

[Backlight Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 7 // SCENE_MODE (Backlight)

[HighSens Scene]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 8 // SCENE_MODE (HighSens)

[Night Portrait]
BITFIELD= 0x4002, 0x8000, 0 // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 9 // SCENE_MODE (NightPortrait)

[Beach Scene]
BITFIELD= 0x4002, 0x8000, 0  // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 10 // SCENE_MODE (Beach)

[Document Scene]
BITFIELD= 0x4002, 0x8000, 0  // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 11 // SCENE_MODE (Document)

[Party Scene]
BITFIELD= 0x4002, 0x8000, 0  // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 12 // SCENE_MODE (Party)

[Fireworks Scene]
BITFIELD= 0x4002, 0x8000, 0  // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 13 // SCENE_MODE (Fireworks)

[Sunset Scene]
BITFIELD= 0x4002, 0x8000, 0  // SCENE_MODE (Manual)
BITFIELD= 0x4002, 0x000F, 14 // SCENE_MODE (Sunset)

//Status On Screen Display
[SS OFF]
BITFIELD= 0x2018, 0x1000, 0 
BITFIELD= 0x3018, 0x1000, 0 

[SS ON]
BITFIELD= 0x2018, 0x1000, 1
BITFIELD= 0x3018, 0x1000, 1

//Auto White Balance Modes (Bit 0:7)
[Auto AWB]
BITFIELD= 0x4030, 0x001F, 0x1F // AWB

[Temp AWB]
BITFIELD= 0x4030, 0x001F, 0x10 // Temperature/Gain AWB

[D75 AWB]
BITFIELD= 0x4030, 0x001F, 0x11 // D75 AWB

[D65 AWB]
BITFIELD= 0x4030, 0x001F, 0x12 // D65 AWB

[D50 AWB]
BITFIELD= 0x4030, 0x001F, 0x13 // D50 AWB

[CWF AWB]
BITFIELD= 0x4030, 0x001F, 0x14 // CWF AWB

[A AWB]
BITFIELD= 0x4030, 0x001F, 0x15 // A AWB

[Hroiz AWB]
BITFIELD= 0x4030, 0x001F, 0x16 // Horizon AWB

[White AWB]
BITFIELD= 0x4030, 0x001F, 0x17 // White point AWB


//AE Mode (Bit 0:15)
[Average AE]
BITFIELD= 0x4048, 0xFFFF, 0 // AE_MODE (Average)

[Wide Center AE]
BITFIELD= 0x4048, 0xFFFF, 1 // AE_MODE (Wide Center)

[Narrow Center AE]
BITFIELD= 0x4048, 0xFFFF, 2 // AE_MODE (Narrow Center)

[Spot AE]
BITFIELD= 0x4048, 0xFFFF, 3 // AE_MODE (Spot)

[Manual AE]
BITFIELD= 0x4048, 0xFFFF, 4 // AE_MODE (Manual/Table)

// Auto Exposure
[Auto Exposure]
IF_FIELD= AE_MODE,AUTO,==1, LOAD= AE OFF, ELSELOAD= AE ON
[AE OFF]
BITFIELD= 0x4014, 0x0001, 0 // AE_MODE (Auto off)
[AE ON]
BITFIELD= 0x4014, 0x0001, 1 // AE_MODE (Auto on)

[FACEBOUND AE]
IF_FIELD= AE_MODE,FACE_BOUND,==1, LOAD= FACEBOUND OFF, ELSELOAD= FACEBOUND ON
[FACEBOUND ON]
BITFIELD= 0x4014, 0x0100, 1 // AE_MODE (Face bound on)
[FACEBOUND OFF]
BITFIELD= 0x4014, 0x0100, 0 // AE_MODE (Face bound off)

[ROI AE]
LOAD= AE ON
LOAD= Python: set_AE_ROI

[Time Stamp On]
REG= 0x1118, 0xDFC7          // x, y position
REG= 0x111C, 0x1063          // init size font
REG= 0x111E, 0x0430          // write time date
REG= 0x1120, 0x393A
REG= 0x1122, 0x3233
REG= 0x1124, 0x414D
REG= 0x1126, 0x0A30
REG= 0x1128, 0x312F
REG= 0x112A, 0x3032
REG= 0x112C, 0x2F32
REG= 0x112E, 0x3031
REG= 0x1130, 0x3100
BITFIELD= 0x3016, 0x0002, 1   // SNAPSHOT_ENABLE_TEXT

[Time Stamp OFF]
BITFIELD= 0x3016, 0x0002, 0   // SNAPSHOT_ENABLE_TEXT

//Color Map (bit 15)
[Color Map ON]
BITFIELD= 0x1006, 0x8000, 1 // ENABLE (ON)

[Color Map OFF]
BITFIELD= 0x1006, 0x8000, 0 // DISABLE (OFF)


//ATMG, ATM, LTM (Bit 2,3,14)
[WDR ON]
BITFIELD= 0x1006, 0x0004, 1 // ENABLE ATMG (ON)
BITFIELD= 0x1006, 0x0008, 1 // ENABLE ATM  (ON)
BITFIELD= 0x1006, 0x4000, 1 // ENABLE LTM  (ON)

[WDR OFF]
BITFIELD= 0x1006, 0x0004, 0 // DISABLE ATMG (OFF)
BITFIELD= 0x1006, 0x0008, 0 // DISABLE ATM  (OFF)
BITFIELD= 0x1006, 0x4000, 0 // DISABLE LTM  (OFF)

// Filters, BPC (Bit 8), De-Noise (Bit 12)
[Defect Correct]
IF_FIELD=ENABLE,BPC,==1,LOAD=Defect Correction OFF,ELSELOAD=Defect Correction ON

[Defect Correction ON]
BITFIELD= 0x1006, 0x0100, 1 // Defect Correction ENABLE (ON)

[Defect Correction OFF]
BITFIELD= 0x1006, 0x0100, 0 // Defect Correction DISABLE (OFF)

[Noise Filter]
IF_FIELD=ENABLE,DEN,==1,LOAD=Noise Filter OFF,ELSELOAD=Noise Filter ON

[Noise Filter ON]
BITFIELD= 0x1006, 0x1000, 1 // Noise Filter ENABLE (ON)

[Noise Filter OFF]
BITFIELD= 0x1006, 0x1000, 0 // Noise Filter DISABLE (OFF)

//Antishake (bit 1)
[Antishake ON]
BITFIELD= 0x2012, 0x0002, 1 // PREVIEW_CTRL (ASHAKE ON)
BITFIELD= 0x3012, 0x0001, 1 // SNAPSHOT_CTRL (ASHAKE ON)

[Antishake OFF]
BITFIELD= 0x2012, 0x0002, 0 // PREVIEW_CTRL (ASHAKE OFF)
BITFIELD= 0x3012, 0x0001, 0 // SNAPSHOT_CTRL (ASHAKE OFF)

[Antishake Demo]
LOAD= Python: AntiShake_Demo

[Panorama Demo]
REG= 0x202E, 0x521	//Turn on Panoramic mode
PROMPT= "Choose which type of images to save", "Full Size", LOAD=Python: input_capture_full, "Preview", LOAD=Python: input_capture
//REG= 0x2018, 0x0001	//JPEG Format
//STATE= Still Mode, 1	//Current display image
//STATE= Save JPEG, 1
//SAVE_IMAGE = 0
//LOAD=Viewfinder ON

//LOAD= Python: input_capture

//PROMPT= "Please move/align camera to get next image"
//SAVE_IMAGE = Panorama_.jpg
//REG=0x1000, 0xC
//LOAD=Viewfinder ON
//POLL_REG= 0x1000, 0xFFFF, !=4, DELAY=100, TIMEOUT=20
//LOAD= Python: CaptureInput
//PROMPT= "Please move/align camera to get next image"
//SAVE_IMAGE = Panorama_.jpg
//REG= 0x1000, 0
//LOAD= Viewfinder ON
//REG= 0x202E, 0x520
//REG= 0x2018, 0x0062	//Back to YCbCr Format
[Python: DVS Split Screen ON/OFF]
if (devware.getstate('DVS Split Screen')):
	devware.setstate('DVS Split Screen', 0)
else:
	devware.setstate('DVS Split Screen', 1)

[Smile Shutter Release Demo]
STATE= Num Capture Frames, 1
LOAD= Face Detection ON
LOAD= Smile Detection ON
BITFIELD= 0x1004, 0x0F00, 3 // DevWare may lose the first frame
BITFIELD= 0x1004, 0x0002, 1
REG= 0x1000, 0x001C

[No-Blink Shutter Release Demo]
STATE= Num Capture Frames, 1
LOAD= Face Detection ON
LOAD= Smile Detection ON
LOAD= Blink_Shutter ON
FIELD_WR= S2_CTRL, BLINK, 1

[Auto Shutter Release OFF]
BITFIELD= 0x1004, 0x0007, 0
REG= 0x1000, 0

[Bracket Exposure]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 0x055	// Exposure step 0.3 (s7.8)
REG= 0x11A0, 0
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket ISO]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 100	// ISO 100
REG= 0x11A0, 1
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket Color]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 150	// Temperature step 
REG= 0x11A0, 2
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket Green]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 0xc8	// Green gain step 
REG= 0x11A0, 3
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket Contrast]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 0x7530	// contrast step 1
REG= 0x11A0, 4
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket Lens]
STATE= Num Capture Frames, 3
REG= 0x119A, 3
REG= 0x119C, 10		// Lens position step 10
REG= 0x11A0, 5
BITFIELD= 0x1004, 0x0F00, 3 

[Bracket Off]
STATE= Num Capture Frames, 1
REG= 0x119A, 0
REG= 0x119C, 0x32		// Lens position step 10
REG= 0x11A0, 0
BITFIELD= 0x1004, 0x0F00, 1 

//Special Effect Modes (Bit 0:7)
[Normal Mode]
BITFIELD= 0x1012, 0x00FF, 0 //No Special Effect (Normal)

[Alien Mode]
BITFIELD= 0x1012, 0x00FF, 1

[Antique Mode]
BITFIELD= 0x1012, 0x00FF, 2

[B/W Mode]
BITFIELD= 0x1012, 0x00FF, 3

[Emboss Mode]
BITFIELD= 0x1012, 0x00FF, 4

[Emboss/Color Mode]
BITFIELD= 0x1012, 0x00FF, 5

[Grayscale Mode]
BITFIELD= 0x1012, 0x00FF, 6

[Negative Mode]
BITFIELD= 0x1012, 0x00FF, 7

[Blueish Mode]
BITFIELD= 0x1012, 0x00FF, 8

[Greenish Mode]
BITFIELD= 0x1012, 0x00FF, 9

[Redish Mode]
BITFIELD= 0x1012, 0x00FF, 10

[Posterize1 Mode]
BITFIELD= 0x1012, 0x00FF, 11

[Posterize2 Mode]
BITFIELD= 0x1012, 0x00FF, 12

[Sepia1 Mode]
BITFIELD= 0x1012, 0x00FF, 13

[Sepia2 Mode]
BITFIELD= 0x1012, 0x00FF, 14

[Sketch Mode]
BITFIELD= 0x1012, 0x00FF, 15

[Solarize Mode]
BITFIELD= 0x1012, 0x00FF, 16

//AF Modes (Bit 0:3)
[Manual AF]
BITFIELD= 0x4004, 0x000F, 0 // AF_MODE (Manual)

[Single AF]
BITFIELD= 0x4004, 0x000F, 1 // AF_MODE (Single)

[Continuous AF]
BITFIELD= 0x4004, 0x000F, 3 // AF_MODE (Continuous)

[Continuous Single AF]
BITFIELD= 0x4004, 0x000F, 4 // AF_MODE (Continuous Single)

[FACEROI AF]
IF_FIELD= AF_MODE,FACE_ROI_ENABLE,==1, LOAD= FACEROI AF OFF, ELSELOAD= FACEROI AF ON
[FACEROI AF ON]
BITFIELD= 0x4004, 0x0020, 1 // AF_MODE (FACE ROI ON)
[FACEROI AF OFF]
BITFIELD= 0x4004, 0x0020, 0 // AF_MODE (FACE ROI OFF)

[CENTER AF]
IF_FIELD= AF_MODE,CENTER_ROI_ENABLE,==1, LOAD= CENTER AF OFF, ELSELOAD= CENTER AF ON
[CENTER AF ON]
BITFIELD= 0x4004, 0x0040, 1 // AF_MODE (CENTER ON)
[CENTER AF OFF]
BITFIELD= 0x4004, 0x0040, 0 // AF_MODE (CENTER OFF)

[ROI AF]
BITFIELD= 0x4004, 0x0010, 1 // AF_MODE (Manual ROI Enable)
LOAD=Python: set_AF_ROI
LOAD= Single AF

[Raw Bypass ON]
BITFIELD= 0x2018, 0x00F0, 5 // Raw format (preview)
BITFIELD= 0x3018, 0x00F0, 5 // Raw format (snapshot)

[Raw Bypass OFF]
BITFIELD= 0x2018, 0x00F0, 6 // YUV-JFIF format (preview)
BITFIELD= 0x3018, 0x00F0, 6 // YUV-JFIF format (snapshot)

[Preview VGA]
REG= 0x2002, 480   // preview_height
REG= 0x2000, 640   // preview_width
REG= 0x2008, 0     // preview_roi_x0
REG= 0x200A, 65535 // preview_roi_x1
REG= 0x200C, 0     // preview_roi_y0
REG= 0x200E, 65535 // preivew_roi_y1

[Preview 720p]
REG= 0x2002, 720  // preview_height
REG= 0x2000, 1280 // preview_width
REG= 0x2008, 0    // preview_roi_x0
REG= 0x200A, 3264 // preview_roi_x1
REG= 0x200C, 157  // preview_roi_y0
REG= 0x200E, 1076 // preivew_roi_y1
REG= 0x201a, 1    // preview_sensor_mode = 1
// REG= 0x2024, 30000 // preview_upper_et 
// REG= 0x2028, 33000 // preview_max_et 

[Preview 1080p]
REG= 0x201a, 0    // preview_sensor_mode = 0
REG= 0x2008, 200   // preview_roi_x0
REG= 0x200A, 3079  // preview_roi_x1
REG= 0x200C, 422   // preview_roi_y0
REG= 0x200E, 2041  // preivew_roi_y1
REG= 0x2002, 1080  // preview_height
REG= 0x2000, 1920  // preview_width
REG= 0x2024, 40000 // preview_upper_et 
REG= 0x2028, 40000 // preview_max_et 

[Python:]
import os
import math
import ctypes
import threading

verbose_out = 0	  
verbose_buff = []
lp_Addr = 0
AE_grid = 8
__script_timeout = 0

#  This class definition goes with OpenFileDialog()
class OPENFILENAMEW(ctypes.Structure):
	_fields_ = [("lStructSize", ctypes.c_ulong),
		("hwndOwner", ctypes.c_void_p),
		("hInstance", ctypes.c_void_p),
		("lpstrFilter", ctypes.c_wchar_p),
		("lpstrCustomFilter", ctypes.c_wchar_p),
		("nMaxCustFilter", ctypes.c_ulong),
		("nFilterIndex", ctypes.c_ulong),
		("lpstrFile", ctypes.c_wchar_p),
		("nMaxFile", ctypes.c_ulong),
		("lpstrFileTitle", ctypes.c_wchar_p),
		("nMaxFileTitle", ctypes.c_ulong),
		("lpstrInitialDir", ctypes.c_wchar_p),
		("lpstrTitle", ctypes.c_wchar_p),
		("Flags", ctypes.c_ulong),
		("nFileOffset", ctypes.c_ushort),
		("nFileExtension", ctypes.c_ushort),
		("lpstrDefExt", ctypes.c_wchar_p),
		("lCustData", ctypes.c_ulong),
		("lpfnHook", ctypes.c_void_p),
		("lpTemplateName", ctypes.c_wchar_p),
		("pvReserved", ctypes.c_void_p),
		("dwReserved", ctypes.c_ulong),
		("FlagsEx", ctypes.c_ulong)]

def OpenFileDialog(title, initialdir, def_extension, filter):
	OFN_PATHMUSTEXIST  =  0x00000800
	OFN_FILEMUSTEXIST  =  0x00001000
	flags = OFN_PATHMUSTEXIST + OFN_FILEMUSTEXIST # allow only existing files
	filename_buf = ctypes.create_unicode_buffer(512)
	ofn = OPENFILENAMEW(88, 0, 0, filter, 0, 0, 1,\
		ctypes.cast(filename_buf, ctypes.c_wchar_p), 512,\
		0, 0, initialdir, title, flags, 0, 0, def_extension, 0, 0, 0,\
		0, 0, 0)
	#  Create and show the dialog
	ret = ctypes.windll.Comdlg32.GetOpenFileNameW(ctypes.byref(ofn))
	#  If the return value is 1 then filename_buf.value is the complete path
	#  of the chosen file
	if (ret == 1):
		return filename_buf.value
	return None

class XmlRegs:
	def __init__(self, name):
		self.name = name
		self.data = []
	
	#reg = (addr, size, value)
	def addReg(self, reg):
		self.data.append(reg)

class XmlDump:
	def __init__(self, name, addr=-1):
		self.name = name
		self.addr = addr
		self.data = []

	def addByte(self, val):
		self.data.append(val)

class Xml:
	def __init__(self):
		self.sections = []
		self.defines = []
	
	def addDump(self, dump):
		self.sections.append(("dump", dump))
	def addRegs(self, regs):
		self.sections.append(("regs", regs))
	def addDefine(self, name, value):
		self.defines.append((name, value))

	def getDump(self, name):
		for s in self.sections:
			if s[0] == "dump" and s[1].name == name:
				return s[1]
		return None
	def getRegs(self, name):
		for s in self.sections:
			if s[0] == "regs" and s[1].name == name:
				return s[1]
		return None
	def getDefine(self, name):
		for d in self.defines:
			if (d[0] == name):
				return d[1]
		return None
	
	def parse(self, infile):	
		xmlFile = open(infile, mode="r")
		xmlData = xmlFile.read().split()
		xmlFile.close()

		sdump = None
		sregs = None

		name = ""
		addr = -1
		val = -1

		state = 0 
		for tk in xmlData:
			if state == 0: #nowhere
				if tk == "<init>":
					state = 10
			elif state == 10: #in init
				if tk == "<dump":
					state = 20
				if tk == "<regs":
					state = 30
			#	if tk == "<meta>":
			#		state = 40
				if tk == "</init>":
					state = 0

			elif state == 20: #in dump start tag
				if tk.startswith("name="):
					name = tk.split('"')[1];
				if tk.startswith("addr="):
					addr = int(tk.split('"')[1], 16);

				if tk.endswith('>'): #end of start tag ... create dump section
					sdump = XmlDump(name, addr) 
					state = 21
			elif state == 21: #in dump 
				if tk == "</dump>": #end of dump ... add to seciotn
					self.addDump(sdump)
					name = ""
					addr = -1
					sdump = None
					state = 10
				else:	#breake to bytes ... and add to dump
					for i in range(int(len(tk) / 2)):
						s = i * 2
						val = int(tk[s:s + 2], 16)
						sdump.addByte(val)
					
					state = 21

			elif state == 30: #in regs start tag
				if tk.startswith("name="):
					name = tk.split('"')[1];

				if tk.endswith('>'):
					sregs = XmlRegs(name)
					state = 31
			elif state == 31: #in dump 
				if tk == "</regs>": #end of regs ... add to section
					self.addRegs(sregs)
					name = ""
					sregs = None
					state = 10
				else:	#tk is register address
					addr = int(tk, 16)
					state = 32
			elif state == 32: #reading reg value
					val = int(tk, 16)
					sregs.addReg((addr, len(tk) * 4, val))
					state = 31

			#elif state == 40: #reading meta
			#	if tk == "</meta>":
			#		state = 10
			#	elif tk == "BASIC,":
			#		state = 41
			#	elif tk == "VAR,":
			#		state = 43
			#elif state == 41: #basic name
			#	name = tk[0:-1] #remove ,
			#	state = 42
			#elif state == 42: #basic value
			#	self.addDefine("BASIC."+name, int(tk, 16));
			#	state = 40
			#elif state == 43: #var name
			#	name = tk[0:-1] #remove ,
			#	state = 44
			#elif state == 44: #var value
			#	self.addDefine("VAR."+name, int(tk[0:-1], 16));
			#	state = 40

				
class I2CConsole:
	def __init__(self, wp_addr = 0x52, rp_addr = 0x608a, size_addr = 0x54, buff_addr = 0x56):
		self.last_wp = 0
		
		self.wp_addr = wp_addr
		self.rp_addr = rp_addr
		self.size_addr = size_addr
		self.buff_addr = buff_addr

		self.size = read16(size_addr)

	def reset(self):
		self.last_wp = 0

	def read(self):
		str = ""
		
		wp = read16(self.wp_addr)
		len = wp - self.last_wp
		
		#some checks ...
		if len == 0:
			return #empty
		if len > self.size:
			str += "### missing data ###"
			len = self.size
		
		#calc corret wp
		wp = self.last_wp + len
		
		 #get index inside buffer
		indx = self.last_wp % self.size
		#and correct the wp
		self.last_wp = wp
		#where am i going to stop reading ... for blocking mode
		#rp = (wp - 1) % self.size 
		
		# now read
		
		while len > 0:
			r = read16(self.buff_addr + indx)
			ch = (r >> 8) & 0xff
			if ch == 0:
				break
			str += chr(ch)
			ch = r & 0xff
			if ch == 0:
				break
			str += chr(ch)
			
			indx += 2
			len -= 2
			
			if indx >= self.size:
				indx = 0
	
		return str
				
				
				
				

def read16(addr, verbose=False):
	icphd = midlib.Camera(0).sensor
	r = midlib.Register(ship_addr=icphd.ship_addr, addr_size=icphd.addr_size, data_size=16, addr=addr)
	val = r.value

	return val

def write16(addr, val, verbose=False):
	if verbose:
		#print("W16: ", hex(addr), " = ", hex(val))
		tmpstring = "%X %X\n" % (addr, val)
		verbose_buff.append(tmpstring)

	icphd = midlib.Camera(0).sensor
	r = midlib.Register(ship_addr=icphd.ship_addr, addr_size=icphd.addr_size, data_size=16, addr=addr)
	r.value = val


def read32(addr, verbose = False):
	#r1 = read16(addr + 0)
	#r2 = read16(addr + 2)
	#val = (r1 << 16) | (r2 & 0xffff)

	icphd = midlib.Camera(0).sensor
	r = midlib.Register(ship_addr=icphd.ship_addr, addr_size=icphd.addr_size, data_size=32, addr=addr)
	val = r.value
	

	#if verbose:
	#	print("R32: ", hex(addr), " = ", hex(val))

	return val

def write32(addr, val, verbose=False):
	if verbose:
		#print("W32(16): ", hex(addr), " = ", hex(val >> 16))
		#print("W32(16): ", hex(addr+2), " = ", hex(val & 0xFFFF))
		tmpstring = "%X %X\n" % (addr, (val >> 16))
		verbose_buff.append(tmpstring)
		tmpstring = "%X %X\n" % ((addr+2), (val & 0xFFFF))
		verbose_buff.append(tmpstring)

	#write16(addr + 0, (val >> 16) & 0xffff)
	#write16(addr + 2, val & 0xffff)

	icphd = midlib.Camera(0).sensor
	r = midlib.Register(ship_addr=icphd.ship_addr, addr_size=icphd.addr_size, data_size=32, addr=addr)
	r.value = val
	

def loadDump(dump, addr):
	print("loading dump", dump.name, " to address ", hex(addr))

	cnt = len(dump.data)

	i = 0
	while i < cnt:
		l = 0;
		buff = []
		while l < 62 and i + l < cnt:
			buff.append((dump.data[i + l + 0] << 8) | (dump.data[i + l + 1] & 0xff))
			l += 2

		write32(0xf03c, addr + i, verbose_out)
		write16(0xe000, buff)
		if verbose_out:
			for j in range(0, len(buff), 1):
				#print("W16: ", hex(0xe000+(j*2)), " = ", hex(buff[j]))
				tmpstring = "%X %X\n" % ((0xe000+(j*2)), buff[j])
				verbose_buff.append(tmpstring)

		i += l


def loadRegs(regs):
	print("loading regs ", regs.name)
	for r in regs.data:
		if r[1] == 8: #byte value
			pass
		elif r[1] == 16: #short value
			write16(r[0], r[2] & 0xffff, verbose_out)
		elif r[1] == 32: #int value
			write32(r[0], r[2] & 0xffffffff, verbose_out)
			
def waitWhile(addr, mask, val):
	r = read16(addr)
	cnt = 0;
	
	#if verbose_out:
	#	verbose_buff.append("//Wait_While\n")

	while r & mask == val and cnt < 100:
		r = read16(addr)
		cnt += 1
		
	if verbose_out:
		verbose_buff.append("DELAY=50\n")
	
	return cnt

def waitWhileNot(addr, mask, val):
	r = read16(addr)
	cnt = 0;
	
	#if verbose_out:
	#	verbose_buff.append("//Wait_While_Not\n")

	while r & mask != val and cnt < 100:
		r = read16(addr)
		cnt += 1
		
	if verbose_out:
		verbose_buff.append("DELAY=50\n")

	return cnt
		
def probe_far_bus():
	#  Init clocks and release sensor RESETs
	write16(0xf03e, 0x2080)
	write16(0xf03c, 0x8)
	write16(0xe002, 0x4)
	write16(0xe008, 0x800)
	write16(0xe008, 0x8800)
	write16(0xe008, 0x800)
	write16(0xf03e, 0x4010)
	write16(0xf03c, 0x9)
	write16(0xe002, 0x3e7)
	write16(0xf03c, 0x0009)
	write16(0xf03e, 0x5000)
	write16(0xe002, 0x8cf0)
	try:
		midlib.Camera(0).probe_far_bus()
	except:
		pass

def loadXML(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	print("Load in: ", dropname)
	xml.parse(dropname)

	if verbose_out:
		verbose_file = os.path.dirname(__IniFileName) + '\\' + "ICP-HD_Loading_I2C_Log.txt"
		VERBO = open(verbose_file,"w")

	print("waiting for ID")
	waitWhile(0, 0xffff, 0)

	probe_far_bus()

	#
	# load hp basic init registers and start pll settings
	#
	s = xml.getRegs("basic_init_hp")
	if s != None:
		loadRegs(s)
	
		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x01, verbose_out)
		midlib.delay(50)
		if verbose_out:
			verbose_buff.append("DELAY=50\n")
		waitWhile(addr, 0x01, 0x01)

	#
	# load hp patch and run it
	#
	s = xml.getDump("patch_hp")
	if s != None:
		addr = read32(0xf02c, verbose_out)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02, verbose_out)
		waitWhile(addr, 0x02, 0x02)
	
	#
	# load hp scratchpad
	#
	s = xml.getDump("scratchpad_hp")
	if s != None:
		addr = read32(0xf02c, verbose_out)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# start frames
	#
	#addr = xml.getDefine("BASIC.sys_start")
	addr = 0x601A
	write16(addr, 0x10, verbose_out)
	waitWhile(addr, 0x10, 0x10)

	#
	# load lp patch and run it
	#
	s = xml.getDump("patch_lp")
	if s != None:
		#addr = xml.getDefine("BASIC.patch_adr")
		addr = 0x601C
		addr = read32(addr)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02, verbose_out)
		waitWhile(addr, 0x02, 0x02)
	
	#
	# load calib scratchpad
	#
	spaddr = 0
	s = xml.getDump("scratchpad_calib")
	if s != None:
		spaddr = s.addr
	if (midlib.Camera(0).load_prom(0xA8, 'SCRATCHPAD', label='0EC1', dest=spaddr) == True):
		print('loaded dump scratchpad_calib from EEPROM to address 0x%x' % (read32(0xf02c) + spaddr - 0xa000))
	else:
		if s != None:
			addr = read32(0xf02c)
			addr = addr + (s.addr - 0xa000)
			loadDump(s, addr)

	#
	# load lp scratchpad
	#
	s = xml.getDump("scratchpad_lp")
	if s != None:
		addr = read32(0xf02c)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# load calib basic init registers
	#
	if (midlib.Camera(0).load_prom(0xA8, 'CCM', label='0EC1') == True):
		print('loaded regs basic_init_calib from EEPROM')
	else:
		s = xml.getRegs("basic_init_calib")
		if s != None:
			loadRegs(s)
	#
	# load lp basic init registers
	#
	s = xml.getRegs("basic_init_lp")
	if s != None:
		loadRegs(s)
	
	if verbose_out:
		VERBO.writelines(verbose_buff)
		VERBO.close()

	#
	# This passes the xml file name to the Register dialog so it can
	# load the symbols
	#
	xmlopt = 'Xml for ' + midlib.Camera(0).sensor.name + '-' + midlib.Camera(0).sensor.version_name
	devware.setoption_str(xmlopt, dropname)

	# Trigger DevWare to sync up image format, etc.
	devware.command(devware.ID_FILE_CHECKSENSORSTATE)

	
def loadXML_hp_all(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	print("Loadin ", dropname)
	xml.parse(dropname)

	if verbose_out:
		VERBO = open("Verbose_output.txt","w")

	print("waiting for ID")
	waitWhile(0, 0xffff, 0)

	#
	# load hp basic init registers and start pll settings
	#
	s = xml.getRegs("basic_init_hp")
	if s != None:
		loadRegs(s)
	
		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x01, verbose_out)
		midlib.delay(50)
		if verbose_out:
			verbose_buff.append("DELAY=50\n")
		waitWhile(addr, 0x01, 0x01)

	#
	# load hp patch and run it
	#
	s = xml.getDump("patch_hp")
	if s != None:
		addr = read32(0xf02c, verbose_out)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02, verbose_out)
		waitWhile(addr, 0x02, 0x02)
	
	#
	# load hp scratchpad
	#
	s = xml.getDump("scratchpad_hp")
	if s != None:
		addr = read32(0xf02c, verbose_out)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# start frames
	#
	#addr = xml.getDefine("BASIC.sys_start")
	addr = 0x601A
	write16(addr, 0x10, verbose_out)
	waitWhile(addr, 0x10, 0x10)

	if verbose_out:
		VERBO.writelines(verbose_buff)
		VERBO.close()


def loadXML_lp_all(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	print("Loadin ", dropname)
	xml.parse(dropname)

	if verbose_out:
		VERBO = open("Verbose_output.txt","w")

	print("waiting for ID")
	waitWhile(0, 0xffff, 0)
 
	#
	# load lp patch and run it
	#
	s = xml.getDump("patch_lp")
	if s != None:
		#addr = xml.getDefine("BASIC.patch_adr")
		addr = 0x601C
		addr = read32(addr)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02, verbose_out)
		waitWhile(addr, 0x02, 0x02)
	
	#
	# load calib scratchpad
	#
	s = xml.getDump("scratchpad_calib")
	if s != None:
		addr = read32(0xf02c)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# load lp scratchpad
	#
	s = xml.getDump("scratchpad_lp")
	if s != None:
		addr = read32(0xf02c)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# load calib basic init registers
	#
	s = xml.getRegs("basic_init_calib")
	if s != None:
		loadRegs(s)
	#
	# load lp basic init registers
	#
	s = xml.getRegs("basic_init_lp")
	if s != None:
		loadRegs(s)
	
	if verbose_out:
		VERBO.writelines(verbose_buff)
		VERBO.close()


def loadXML_basic_hp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	print("Loadin ", dropname)
	xml.parse(dropname)

	print("waiting for ID")
	waitWhile(0, 0xffff, 0)

	#
	# load hp basic init registers and start pll settings
	#
	s = xml.getRegs("basic_init_hp")
	if s != None:
		loadRegs(s)
	
		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x01)
		waitWhile(addr, 0x01, 0x01)
			
def loadXML_hp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	print("Loadin ", dropname)
	xml.parse(dropname)

	s = xml.getDump("patch_hp")
	if s != None:
		addr = read32(0xf02c)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02)
		waitWhile(addr, 0x02, 0x02)
		
	#
	# load hp scratchpad
	#
	s = xml.getDump("scratchpad_hp")
	if s != None:
		addr = read32(0xf02c)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	#
	# start frames
	#
	#addr = xml.getDefine("BASIC.sys_start")
	addr = 0x601A
	write16(addr, 0x10)
	waitWhile(addr, 0x10, 0x10)

def load_Patch_lp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	xml.parse(dropname)

	#
	# load lp patch and run it
	#
	s = xml.getDump("patch_lp")
	if s != None:
		#addr = xml.getDefine("BASIC.patch_adr")
		addr = 0x601C
		addr = read32(addr)
		loadDump(s, addr)

		#addr = xml.getDefine("BASIC.sys_start")
		addr = 0x601A
		write16(addr, 0x02)
		waitWhile(addr, 0x02, 0x02)

def load_Scratchpad_hp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	xml.parse(dropname)

        #
	# load hp scratchpad
	#
	s = xml.getDump("scratchpad_hp")
	if s != None:
		addr = read32(0xf02c, verbose_out)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

	
def load_Scratchpad_lp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	xml.parse(dropname)

	#
	# load lp scratchpad
	#
	s = xml.getDump("scratchpad_lp")
	if s != None:
		addr = read32(0xf02c)
		addr = addr + (s.addr - 0xa000)
		loadDump(s, addr)

def load_basic_lp(dropname):
	xml = Xml()
	if (os.path.dirname(dropname) == ''):
		dropname = os.path.dirname(__IniFileName) + '\\' + dropname
	xml.parse(dropname)

	#
	# load lp basic init registers
	#
	s = xml.getRegs("basic_init_lp")
	if s != None:
		loadRegs(s)


#
#  This function will generate a csv file for RegDB of any
#  advanced registers listed in the XML file that are not
#  already in the sdat file.
#
#def regdb():
#	title = 'Select ICP-HD XML File'  #  Window title bar
#	initialdir = os.path.dirname(__IniFileName)
#	def_extension = 'xml'  #  default file extension
#	filter = 'XML Files\0*.xml\0All Files\0*.*\0\0' # file extension filters
#	dropname = OpenFileDialog(title, initialdir, def_extension, filter)
#	if (dropname == None):
#		return
#
#	xml = Xml()
#	xml.parse(dropname)
#	for d in xml.defines:
#		type = d[0].split('.')[0]
#		name = d[0].split('.')[1]
#		addr = d[1]
#		if type == 'VAR' and !reg.exists(name):
#			


#
# readcon function will read the current buffer from iCop i2c console
#
def readcon():
	i = I2CConsole()
	str = i.read()
	print(str)


#
# Test writing to slave devices of ICP
#
BASIC_dma_src = 0x608c
BASIC_dma_dst = 0x6090
BASIC_dma_size = 0x6094
BASIC_dma_ctrl = 0x6098

#
# i2cID: sensor id
# aw: address width (0 - 8 bit, 1 - 16 bit)
# dw: data width (0 - 8 bit, 1 - 16 bit)
#
def readSensor(i2cID, aw, dw, addr): 
	write32(BASIC_dma_src, (((((dw << 1) | aw) << 8) | i2cID) << 16) | addr)
	write32(BASIC_dma_dst, BASIC_dma_dst)
	write32(BASIC_dma_size, (dw+1))
	write16(BASIC_dma_ctrl, 0x2032)
	waitWhileNot(BASIC_dma_ctrl, 0x0f, 0)
	value = read16(BASIC_dma_dst)
	return value

#
# i2cID: sensor id
# aw: address width (0 - 8 bit, 1 - 16 bit)
# dw: data width (0 - 8 bit, 1 - 16 bit)
#
def writeSensor(i2cID, aw, dw, addr, value):
	write32(BASIC_dma_src, value)
	write32(BASIC_dma_dst, (((((dw << 1) | aw) << 8) | i2cID) << 16) | addr)
	write32(BASIC_dma_size, (dw+1))
	write16(BASIC_dma_ctrl, 0x2301)
				
	
#
# turn on the panoramic mode and get 3 preview size images (with Overlay)
#
def thread_capture():
	capture_dir = devware.getoption_str('Capture File')
	capture_dir = os.path.dirname(capture_dir)
	devware.setstate("Still Mode", 0)
	devware.setstate("Still Capture Timeout", 10)
	devware.setstate("Save 24bpp BMP", 1)
	devware.setoption("Capture FileName Increment", 0)
	
	#Get the first image
	fullname = os.path.join(capture_dir,'Panorama_1')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK if the camera is ready.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0xC
	timeout = 0
	while(reg.reg(0x1000).uncached_value != 4 and timeout < 200):
		midlib.delay(10)
		timeout += 1
	
	#Get the second image
	fullname = os.path.join(capture_dir,'Panorama_2')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Please move and align the camera.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0xC
	timeout = 0
	while(reg.reg(0x1000).uncached_value != 4 and timeout < 200):
		midlib.delay(10)
		timeout += 1

	#Get the third image
	fullname = os.path.join(capture_dir,'Panorama_3')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Please move and align the camera.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0
	reg.reg(0x202E).value = 0x520
	os.chdir(capture_dir)
	aiv_command = "aiviewer Panorama_1.bmp Panorama_2.bmp Panorama_3.bmp"
	os.system(aiv_command)


#
# turn on the panoramic mode and get 3 full size images
#
def thread_capture_full():
	capture_dir = devware.getoption_str('Capture File')
	capture_dir = os.path.dirname(capture_dir)
	devware.setstate("Still Mode", 1)
	devware.setstate("Still Capture Timeout", 10)
	devware.setstate("Save RAW", 1)
	devware.setstate("Save 24bpp BMP", 0)
	#devware.setstate("Save RAW JPEG", 1)
	devware.setoption("Capture FileName Increment", 0)
	
	#Get the first image
	fullname = os.path.join(capture_dir,'Panorama_1')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK if the camera is ready.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0xC
	timeout = 0
	while(reg.reg(0x1000).uncached_value != 4 and timeout < 200):
		midlib.delay(10)
		timeout += 1
	
	#Get the second image
	fullname = os.path.join(capture_dir,'Panorama_2')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Please move and align the camera.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0xC
	timeout = 0
	while(reg.reg(0x1000).uncached_value != 4 and timeout < 200):
		midlib.delay(10)
		timeout += 1

	#Get the third image
	fullname = os.path.join(capture_dir,'Panorama_3')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Please move and align the camera.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK after the image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	reg.reg(0x1000).value = 0
	reg.reg(0x202E).value = 0x520
	devware.setstate("Save 24bpp BMP", 1)
	#devware.setstate("Save RAW JPEG", 0)
	os.chdir(capture_dir)
	aiv_command = "aiviewer Panorama_1.raw Panorama_2.raw Panorama_3.raw"
	os.system(aiv_command)

def set_ae_roi():
	# Read mouse selections of the ROI coordinates for auto exposure
	img_w = midlib.Camera(0).sensor.width
	img_h = midlib.Camera(0).sensor.height
	factor_w = img_w/(AE_grid*2)
	factor_h = img_h/(AE_grid*2)

	m_sel, pix_x0, pix_y0, pix_x1, pix_y1 = devware.get_mouse_selection()
	if(m_sel != 'point'):
		ctypes.windll.user32.MessageBoxW(0, 'Please use point mouse selection!', 'Error', 0)
		return

	x0 = int(max(0, pix_x0-factor_w))
	y0 = int(max(0, pix_y0-factor_h))
	x1 = int(min(img_w, pix_x0+factor_w+0.5))
	y1 = int(min(img_h, pix_y0+factor_h+0.5))
	if((x1-x0) < (img_w/8)):
		if(x1 == img_w):
			x0 = x0 - int(img_w/8 +0.5)
		else:
			x1 = x1 + int(img_w/8 +0.5) 
	if((y1-y0) < (img_h/8)):
		if(y1 == img_h):
			y0 = y0 - int(img_h/8 +0.5)
		else:
			y1 = y1 + int(img_h/8 +0.5)
 
	devware.set_mouse_selection('rectangle', x0, y0, x1, y1)
	reg.reg(0x4292).bitfield(0x000F).value = min(math.ceil(x0 * (16/img_w)), 15)
	reg.reg(0x4292).bitfield(0x00F0).value = min(math.ceil(y0 * (16/img_h)), 15)
	reg.reg(0x4292).bitfield(0x0F00).value = min(math.ceil(x1 * (16/img_w)) - 1, 15)
	reg.reg(0x4292).bitfield(0xF000).value = min(math.ceil(y1 * (16/img_h)) - 1, 15)

def set_af_roi():
	# Ask user input the 16x16 ROI spot for auto focus
	#spotxy = input("Please type in [X, Y] format: ").split(',', 1)
	#reg.reg(0x4006).bitfield(0x0F00).value = int(spotxy[0].strip())
	#reg.reg(0x4006).bitfield(0xF000).value = int(spotxy[1].strip())
	factor_w = midlib.Camera(0).sensor.width/14
	factor_h = midlib.Camera(0).sensor.height/14
	m_sel, pix_x0, pix_y0, pix_x1, pix_y1 = devware.get_mouse_selection()
	if(m_sel != 'point'):
		ctypes.windll.user32.MessageBoxW(0, 'Please use point mouse selection!', 'Error', 0)
		return
	else:
		reg.reg(0x4006).bitfield(0x0F00).value = int(pix_x0/factor_w) + 1
		reg.reg(0x4006).bitfield(0xF000).value = int(pix_y0/factor_h) + 1

def antishake_demo():
	capture_dir = devware.getoption_str('Capture File')
	capture_dir = os.path.dirname(capture_dir)
	devware.setstate("Still Mode", 0)
	devware.setstate("Still Capture Timeout", 10)
	devware.setstate("Save 24bpp BMP", 1)
	devware.setoption("Capture FileName Increment", 0)
	
	#Turn-on anti-shake
	reg.reg(0x2012).bitfield(0x0002).value = 1
	reg.reg(0x3012).bitfield(0x0001).value = 1
	
	#Get the first image with anti-shake on
	fullname = os.path.join(capture_dir,'AntiShake_On')
	devware.setoption_str("Capture File", fullname)
	ctypes.windll.user32.MessageBoxW(0, 'Click OK if all the test settings are ready.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Antishake-on image is saved! ", timeout)
	#ctypes.windll.user32.MessageBoxW(0, 'Click OK after the antishake-on image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)
	
	#Turn-off anti-shake
	reg.reg(0x2012).bitfield(0x0002).value = 0
	reg.reg(0x3012).bitfield(0x0001).value = 0
	
	#Get the second image with anti-shake off
	fullname = os.path.join(capture_dir,'AntiShake_Off')
	devware.setoption_str("Capture File", fullname)
	#ctypes.windll.user32.MessageBoxW(0, 'Click OK if the camera is ready.', 'Message', 0)
	devware.setstate('Capture Mode', 1)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Antishake-off image is ready! ", timeout)
	devware.setstate('Capture Mode', 7)
	timeout = 0
	while(devware.getstate("Capture Mode") != 9):
		timeout += 1
	print("Image is saved! ", timeout)
	#ctypes.windll.user32.MessageBoxW(0, 'Click OK after the antishake-off image saved!', 'Message', 0)
	devware.setstate('Capture Mode', 8)

	os.chdir(capture_dir)
	aiv_command = "aiviewer AntiShake_On.bmp AntiShake_Off.bmp"
	os.system(aiv_command)

def verify_verbose():
	#
	# load previous generated verbose_output.txt file
	#
	verboName = "Verbose_output.txt"
	verboFile = open(verboName, mode="r")
	verboData = verboFile.read().split()
	verboFile.close()
	
	#  Process <addr> <data> pairs
	i = 0
	while i < len(verboData):
		if verboData[i] == "DELAY=50":
			midlib.delay(50)
			#print("DELAY=50")
			i = i + 1
		else:
			regaddr = int(verboData[i + 0], 16)
			regdata = int(verboData[i + 1], 16)
			write16(regaddr, regdata)
			#print(regaddr, " = ", regdata)
			i = i + 2


[Sensor Pattern 0]
REG= 0x608e, 0
DELAY=10
REG= 0x6090, 0x036C3070
DELAY=10
REG= 0x6098, 0x0301

[Sensor Pattern 1]
REG= 0x608e, 1
DELAY=10
REG= 0x6090, 0x036C3070
DELAY=10
REG= 0x6096, 0x0002
DELAY=10
REG= 0x6098, 0x0301

[Sensor Pattern 2]
REG= 0x608e, 2
DELAY=10
REG= 0x6090, 0x036C3070
DELAY=10
REG= 0x6096, 0x0002
DELAY=10
REG= 0x6098, 0x0301

[Sensor Pattern 3]
REG= 0x608e, 3
DELAY=10
REG= 0x6090, 0x036C3070
DELAY=10
REG= 0x6096, 0x0002
DELAY=10
REG= 0x6098, 0x0301
